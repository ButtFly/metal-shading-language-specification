# 3 运算符

> 所有操作系统：从v1.0开始支持标量、向量和矩阵的运算符。

对于间接命令缓冲器，赋值运算符(=)不会复制命令的内容。有关在间接命令缓冲区复制命令的更多详细信息，请参阅第5.16.1节。

# 3.1 标量和向量运算符

1. 算术运算符，加（+）、减（-）、乘（*）、除（/），可以用于标量、向量、整数和浮点数这类数据类型上。在操作数类型转换之后，所有算术运算符都返回与操作数类型相同的内置类型(整数或浮点)的结果。转换后，以下情况有效：

* 两个操作数都是标量。在这种情况下，结果是一个标量。
* 一个操作数是标量，另一个是向量。在这种情况下，标量将转换为向量操作数使用的元素类型。然后将标量类型扩展为具有与向量操作数相同数量组件的向量。该操作以分量方式执行，结果是相同大小的向量。
* 两个操作数是相同大小的向量。在这种情况下，操作是分量执行的，结果会是同样大小的向量。

对整数类型进行除法运算，导致值超出整数类型的最大和最小值可表示的限定范围，例如对于有符号证书类型的 TYPE_MIN/-1或除以零不会导致异常，但会导致一个未指定的值。根据`IEEE-754`标准的规则，浮点类型除以零的结果是正负无穷大或NaN。（有关浮点运算的数值精度的详细信息，请参阅第7章。）

2. 模运算符（%）可以对标量和向量整数数据类型进行操作。在操作数类型转换之后，所有算术运算符都返回与操作数类型相同的内置类型的结果。以下情况有效：

* 两个操作数是标量。在这种情况下，当运用运算符，结果也是标量。
* 一个操作数是标量，一个操作数是向量。在这种情况下，标量转换为向量操作数使用的数据类型。然后将标量类型扩展为具有与向量操作数相同数量组件的向量。该操作以分量方式执行，结果是相同大小的向量。
* 两个操作数是相同大小的向量。在这种情况下，操作是分量执行的，结果会是同样大小的向量。

对于使用第二个操作数为零计算的任何组件，结果值是未定义的，而具有非零操作数的其他组件的结果仍保持其定义。如果两个操作数都是非负数，则余数为非负数。如果操作数中有一个为负数，则结果是未定义的。

3. 一元运算符(+ 和 -)可以对标量和向量进行操作，操作数的类型为整型或浮点型。

4. 算术前置与后置的递增与递减运算符(`--`和`++`)可以对整数类型的标量与向量进行操作。


5. 关系运算符，大于(>)，小于(<)，大于等于（>=）以及小于等于（<=）,可以用于标量和矢量，整型和浮点型上。结果只是一个布尔（bool）标量或者矢量。

* 运算符两边是标量。这种情况下，当运用运算符操作，结果是一个`bool`值
* 运算符的一边是标量，另一边是矢量。

6. 判相当运算符，等于(==)和不等于（!=）, 可以运用在标量和矩阵、整型和浮点型上。所有判相当的

# 3.2 矩阵运算

算术运算符加(+)和减(-)可以对矩阵进行操作。两个矩阵必须具有相同数量的行和列。操作以分量方式完成，产生相同大小的矩阵。算术运算符乘法(*)操作: 

* 一个标量和一个矩阵
* 一个矩阵和一个标量
* 一个矢量和一个矩阵
* 一个矩阵和一个矢量
* 或者 一个矩阵和另一个矩阵

如果一个操作数是标量，则标量值乘以矩阵的每个分量，得到相同大小的矩阵。右向量操作数被视为列向量，左向量操作数被视为行向量。对于向量-矩阵，矩阵-向量和矩阵-矩阵乘法，左操作数的列数必须等于右操作数的行数。乘法运算执行线性代数乘法，产生一个向量或矩阵，其行数与左操作数相同，列数与右操作数相同。

以下示例假定这些向量、矩阵和标量变量已初始化。下面描述的向量到矩阵、矩阵到向量和矩阵到矩阵乘法运算的部分和的顺序是不确定的。

```metal
float3 v;
float3x3 m;
float a = 3.0f;
```

如下的矩阵到标量的乘法

```metal
float3x3 m1 = m * a;
```

等同于：

```metal
m1[0][0] = m[0][0] * a;
m1[0][1] = m[0][1] * a;
m1[0][2] = m[0][2] * a;
m1[1][0] = m[1][0] * a;
m1[1][1] = m[1][1] * a;
m1[1][2] = m[1][2] * a;
m1[2][0] = m[2][0] * a;
m1[2][1] = m[2][1] * a;
m1[2][2] = m[2][2] * a;
```

向量到矩阵的乘法

```metal
float3 u = v * m;
```
等同于：

```metal
u.x = dot(v, m[0]);
u.y = dot(v, m[1]);
u.z = dot(v, m[2]);
```

如下的矩阵到向量的乘法

```metal
float3 u = m * v;
```
等同于：

```metal
u.x = m[0].x * v.x + m[1].x * v.y + m[2].x * v.z;
u.y = m[0].y * v.x + m[1].y * v.y + m[2].y * v.z;
u.z = m[0].z * v.x + m[1].z * v.y + m[2].z * v.z;
```

矩阵到矩阵的乘法：

```metal
float3x3 r = m * n; // m,n are float3x3
```

等同于:

```metal
r[0].x = m[0].x * n[0].x + m[1].x * n[0].y + m[2].x * n[0].z;
r[0].y = m[0].y * n[0].x + m[1].y * n[0].y + m[2].y * n[0].z;
r[0].z = m[0].z * n[0].x + m[1].z * n[0].y + m[2].z * n[0].z;
r[1].x = m[0].x * n[1].x + m[1].x * n[1].y + m[2].x * n[1].z;
r[1].y = m[0].y * n[1].x + m[1].y * n[1].y + m[2].y * n[1].z;
r[1].z = m[0].z * n[1].x + m[1].z * n[1].y + m[2].z * n[1].z;
r[2].x = m[0].x * n[2].x + m[1].x * n[2].y + m[2].x * n[2].z;
r[2].y = m[0].y * n[2].x + m[1].y * n[2].y + m[2].y * n[2].z;
r[2].x = m[0].z * n[2].x + m[1].z * n[2].y + m[2].z * n[2].z;
```