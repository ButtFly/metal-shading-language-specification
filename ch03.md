# 3 运算符

本章节将介绍Metal中的运算符。

# 3.1 标量和矢量运算符

1. 算术运算符，加（+）、减（-）、乘（*）、除（/），可以用于标量、矢量、整型和浮点型这类数据类型上。所有算术运算符返回一个

* 运算对象是标量类型。这种情况下，运算的结果是一个标量。
* 一个运算对象是标量，另一个运算对象是矢量。这种情况下，标量会被转换成矢量运算对象。标量类型会被。最终是同样大小的矢量。
* 运算符的两边是同样大小的矢量。这种情况下，运算符会进行分量运算，结果会是同样大小的矢量。

对整数类型进行除法运算，。浮点类型除以0的结果是正负无穷大或者NaN，如`IEEE-754`标准中描述的一样。（数字精度或者浮点型运算的详细，可以参考第7章）

2. 模运算符（%），可以用于标量和

* 运算符的两边是标量。这种情况下，当运用运算符操作，结果也是标量。
* 运算符的一边是

3. 

4. 


5. 关系运算符，大于(>)，小于(<)，大于等于（>=）以及小于等于（<=）,可以用于标量和矢量，整型和浮点型上。结果只是一个布尔（bool）标量或者矢量。

* 运算符两边是标量。这种情况下，当运用运算符操作，结果是一个`bool`值
* 运算符的一边是标量，另一边是矢量。

6. 判相当运算符，等于(==)和不等于（!=）, 可以运用在标量和矩阵、整型和浮点型上。所有判相当的

# 3.2 矩阵运算

算术运算符加(+)和减(-)可以对矩阵进行操作。两个矩阵必须具有相同数量的行和列。操作以分量方式完成，产生相同大小的矩阵。算术运算符乘法(*)操作: 

* 一个标量和一个矩阵
* 一个矩阵和一个标量
* 一个矢量和一个矩阵
* 一个矩阵和一个矢量
* 或者 一个矩阵和另一个矩阵

如果一个操作数是标量，则标量值乘以矩阵的每个分量，得到相同大小的矩阵。右向量操作数被视为列向量，左向量操作数被视为行向量。对于向量-矩阵，矩阵-向量和矩阵-矩阵乘法，左操作数的列数必须等于右操作数的行数。乘法运算执行线性代数乘法，产生一个向量或矩阵，其行数与左操作数相同，列数与右操作数相同。

以下示例假定这些向量、矩阵和标量变量已初始化。下面描述的向量到矩阵、矩阵到向量和矩阵到矩阵乘法运算的部分和的顺序是不确定的。

```metal
float3 v;
float3x3 m;
float a = 3.0f;
```

如下的矩阵到标量的乘法

```metal
float3x3 m1 = m * a;
```

等同于：

```metal
m1[0][0] = m[0][0] * a;
m1[0][1] = m[0][1] * a;
m1[0][2] = m[0][2] * a;
m1[1][0] = m[1][0] * a;
m1[1][1] = m[1][1] * a;
m1[1][2] = m[1][2] * a;
m1[2][0] = m[2][0] * a;
m1[2][1] = m[2][1] * a;
m1[2][2] = m[2][2] * a;
```

向量到矩阵的乘法

```metal
float3 u = v * m;
```
等同于：

```metal
u.x = dot(v, m[0]);
u.y = dot(v, m[1]);
u.z = dot(v, m[2]);
```

如下的矩阵到向量的乘法

```metal
float3 u = m * v;
```
等同于：

```metal
u.x = m[0].x * v.x + m[1].x * v.y + m[2].x * v.z;
u.y = m[0].y * v.x + m[1].y * v.y + m[2].y * v.z;
u.z = m[0].z * v.x + m[1].z * v.y + m[2].z * v.z;
```

矩阵到矩阵的乘法：

```metal
float3x3 r = m * n; // m,n are float3x3
```

等同于:

```metal
r[0].x = m[0].x * n[0].x + m[1].x * n[0].y + m[2].x * n[0].z;
r[0].y = m[0].y * n[0].x + m[1].y * n[0].y + m[2].y * n[0].z;
r[0].z = m[0].z * n[0].x + m[1].z * n[0].y + m[2].z * n[0].z;
r[1].x = m[0].x * n[1].x + m[1].x * n[1].y + m[2].x * n[1].z;
r[1].y = m[0].y * n[1].x + m[1].y * n[1].y + m[2].y * n[1].z;
r[1].z = m[0].z * n[1].x + m[1].z * n[1].y + m[2].z * n[1].z;
r[2].x = m[0].x * n[2].x + m[1].x * n[2].y + m[2].x * n[2].z;
r[2].y = m[0].y * n[2].x + m[1].y * n[2].y + m[2].y * n[2].z;
r[2].x = m[0].z * n[2].x + m[1].z * n[2].y + m[2].z * n[2].z;
```