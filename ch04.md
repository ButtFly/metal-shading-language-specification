# 4 函数和变量声明

本章描述了如何声明函数、参数和变量。还详细说明了特性如何与函数、参数和变量一起使用来指定一些限制。

## 4.1 函数

> 所有操作系统：kernel、vetex和fragment属性从v1.0开始就支持。

Metal支持以下函数属性，这些属性限定了函数的使用方式：`vertex`、`fragment`和`kernel`，它们分别在4.1.1、4.1.2和4.1.3节中详述。这些函数属性在函数的开头使用，在返回值之前。

使用了`vertex`、`fragment`和`kernel`函数属性的函数不得调用也使用这些属性的函数，否则会导致编译错误。

可以在命名空间内声明使用`vertex`、`fragment`和`kernel`函数属性的函数。

### 4.1.1 顶点函数(Vertex Functions)

以下示例演示了使用`vertex`属性声明顶点函数的语法。

```metal
vertex void 
my_vertex_func(...) 
{...}
```

### 4.1.2 片段函数(Fragment Functions)

### 4.1.3 内核函数(Kernel Functions)

```metal
kernel void 
my_kernel(...) 
{...}
```

使用`kernel`属性声明的函数必须返回`void`。

` [[max_total_threads_per_threadgroup]]` 函数属性可以与内核函数一起使用，来指定每个线程组的最大线程数。

下面是使用此属性的内核函数示例：

```metal
[[max_total_threads_per_threadgroup(x)]]
kernel void
my_kernel(...)
{...}
```

如果`[[max_total_threads_per_threadgroup]]`的值大于`[MTLDevice maxThreadsPerThreadgroup]`属性，则管道状态会创建失败。

### 4.1.4 Tile函数



## 4.2 Address Space Attributes for Variables and Arguments

`device`、`threadgroup`、`constant` 和 `thread`

`threadgroup_imageblock`



* `device`
* `threadgroup`
* `threadgroup_imageblock` (section 4.2.3)
* `constant` (section 4.2.2)
* `thread` (section 4.2.5)

### 4.2.1 device Address Space

### 4.2.2 threadgroup Address Space

### 4.2.3 threadgroup_imageblock Address Space

### 4.2.4 constant Address Space

### 4.2.5 thread Address Space

## 4.3 函数参数与变量

大部分图像处理器和内核方法的输入和输出是通过参数来传递的。



### 4.3.2 Buffers 和 纹理的结构


## 4.4 存储类说明符

```metal
extern constant float4 noise_table[256];
static constant float4 color_table[256] = { ... }; // static is okay

extern void my_foo(texture2d<float> img);
extern void my_bar(device float *a);

kernel void
my_kernel(texture2d<float> img [[texture(0)]],
          device float *ptr [[buffer(0)]])
{
    extern constant float4 a; 
    static constant float4 b;  // static is an error. 
    static float c; // static is an error.

    ...
    my_foo(img);
    ...
    my_bar(ptr);
    ...
}
```

## 4.5 采样和差值属性

```metal
center_perspective
center_no_perspective
centroid_perspective
centroid_no_perspective
sample_perspective
sample_no_perspective
flat
```

`center_perspective`是默认的采样和差值属性，以下情况例外：

```metal
struct FragmentInput {
     float4 pos [[center_no_perspective]];
     float4 color [[center_perspective]];
     float2 texcoord;
     int index [[flat]];
     float f [[sample_perspective]];
};
```

## 4.6 片段函数 vs. 采样函数



## 4.7 图像块属性

> macOS: 不支持图像块属性
> iOS: 从v2.0开始支持图像块属性

本节介绍几个与图像块(imageblocks)一起使用的属性。在第2.1节中描述了`[[imageblock_data(type)]]`属性，该属性指定在片段函数上具有显式图像块布局的输入和输出图像块。

### 4.7.1 用于匹配和查看图像块数据的成员的用户属性

`[[user(name)]]`属性可用于为片段函数指定图像块数据类型的数据成员的属性名称。如果片段函数中指定的图像块结果是主显式图像块结构的子集，则使用以下规则将与使用片段函数的图像块与在主显式图像块结构中声明的相应数据成员进行匹配：

* 由`[[user(name)]]`给出的每个属性名称对于图像块中的每个数据成员必须是唯一的。
* 如果为数据成员指定了`[[user(name)]]`属性名称，则`name`指定的属性名称必须与主显式图像块结构中声明的数据成员匹配。此外，关联的数据类型也必须匹配。
* 如果未指定`[[user(name)]]`属性，则片段函数的图像块数据类型和主图像块结构的数据成员名称和类型必须匹配。此外，数据成员不能位于视图图像块结构内或主图像块结构的嵌套结构中。

下面的示例显示了使用`[[user(name)]]`属性声明的图像块结构：

示例：

```metal

// The explicit layout imageblock data master struct.
struct IM {
     rgba8unorm<half4> a [[user(my_a), raster_order_group(0)]];
     rgb9e5<float4> b [[user(my_b), raster_order_group(0)]];
     int c [[user(my_c), raster_order_group(0)]];
     float d [[user(my_d), raster_order_group(0)]];
};

// The explicit layout imageblock data view struct for input.
struct IVIn {
     rgb9e5<float4> x [[user(my_b)]]; // Maps to IM::b
     float y [[user(my_d)]]; // Maps to IM::d
};


// The explicit layout imageblock data view struct for output.
struct IVOut {
     int z [[ user(my_c) ]]; // Maps to IM::c
};

// The fragment return struct.
struct FragOut {
     // IVOut is a view of the master IM.
     IVOut i [[ imageblock_data(IM) ]];
};

// IVIn is a view of the master IM.
fragment FragOut
my_fragment(IVIn i [[imageblock_data(IM)]], ...) {
     FragOut fragOut;
     ... = i.x;
     ... = i.y;
     fragOut.i.z = ...;
     return fragOut;
}
```

下面的示例显示了没有使用`[[user(name)]]`属性声明的图像块结构：

```metal
struct IM {
     rgba8unorm<half4> a [[raster_order_group(0)]];
     rgb9e5<float4> b [[raster_order_group(0)]];
     int c [[raster_order_group(0)]];
     float d [[raster_order_group(0)]];
};

struct IVIn {
     rgb9e5<float4> b; // Maps to IM::b
     float d; // Maps to IM::d
};

struct IVOut {
     int c; // Maps to IM::c
};

struct FragOut {
     IVOut i [[imageblock_data(IM)]];
};

fragment FragOut
my_fragment(IVIn i [[imageblock_data(IM)]], ...) {
     FragOut fragOut;
     ... = i.b;
     ... = i.d;
     fragOut.i.c = ...;
     return fragOut;
 }
```

嵌套结构可以在主显式图像块中声明并查看图像块结构。下面的示例显示了图像块中嵌套结构如何与使用`[[user(name)]]`属性声明的数据成员一起使用：

```metal
struct A {
     rgba8unorm<half4> a [[user(A_a)]];
     rgb9e5<float4> b [[user(A_b)]];
};

struct B {
     int a [[user(B_a), raster_order_group(1)]];
     float b [[user(B_b), raster_order_group(2)]];
};

struct IM {
     A a [[user(A), raster_order_group(0)]];
     B b [[user(B)]];
};

struct IVIn {
     A x [[user(A)]]; // Maps to IM::a
};

struct IVOut {
     B y [[user(B)]]; // Maps to IM::b
     rgb9e5<float4> z [[user(A_b)]]; // Maps to IM::A::b
};

struct FragOut {
     IVOut i [[imageblock_data(IM)]];
};

fragment FragOut
my_fragment(IVIn i [[imageblock_data(IM)]], ...) {
     FragOut fragOut;
      ... = i.x;
     fragOut.i.y.a = ...;
     fragOut.i.y.b = ...;
     fragOut.i.z = ...;
     return fragOut;
}
```

视图结构的每个字段必须只对应一个主结构字段。主结构字段可以引用顶级结构字段以及嵌套结构中的字段。两个或多个视图结构字段对同一主结构字段进行别名是非法的。

非法使用示例：

```metal
struct M  {
     struct A {
           int a [[user(x)]];
     }
     b [[user(y), raster_order_group(0)]];
};

struct V {
     int a [[user(x)]];
     M::A b [[user(y)]]; // illegal: b aliases with a
};

fragment void
f(V i [[imageblock_data(M)]])
{...}
```

显式图像块类型不能具有使用`[[color(n)]]`属性声明的数据成员。

## 4.12 附加限制

