# 2 数据类型

本章详细介绍Metal数据类型，包括代表向量(vectors)和矩阵(matrices)的类型。还讨论了原子数据类型、缓冲区(buffers)、纹理、采样器、数组和用户自定义的结构。还描述了类型对齐(Type alignment)和类型转换。

## 2.1 标量数据类型
Metal 支持`表1`中罗列的标量类型，Metal 不支持 `double`, `long`, `unsigned long`, `long long`, `unsigned longlong`和 `long double` 数据类型。

`表1 - Metal 标量数据类型`

| 类型 | 描述 |
| --- | --- |
| bool | 条件数据类型，其值为true或falsee。 值 true 扩展为整数常量1，值 false 扩展为整数常量0。 |
| char <br> int8_t | 带符号的二进制补码8位整数。 |
| unsigned char <br> uchar <br> uint8_t  |  无符号的8位整数 |
| short <br> int16_t| 带符号的二进制补码16位整数 |
| unsigned short <br> ushort <br> uint16_t | 无符号的16位整数 |
| int <br> int32_t | 带符号的二进制补码32位整数 |
| unsigned int <br> uint <br> uint32_t | 无符号的32位整数 |
| half | 一个16位浮点。 半数据类型必须符合IEEE 754 二进制16 存储格式 |
| float | 一个32位浮点。浮点数据类型必须符合IEEE 754 单精度存储格式 |
| size_t| `sizeof`运算符的结果的无符号整数类型。这是一个64无符号整数 | 
| ptrdiff_t | 有符号整数类型，它是两个指针相减的结果。这是一个64带符号整数 |
| void | void类型包含一组空值;它是一种不完整的类型  |

> 注意: Metal 支持标准的 `f`或`F`后缀，以指定单精度浮点字面值(例如，0.5f或0.5F)。此外，Metal支持`h`或`H`后缀以指定半精度浮点字面值（例如，0.5h或0.5H）。Metal还支持无符号整数文字的`u`或`U`后缀。

表2列出了大多数标量数据类型的大小和对齐方式。

`表2 - 标量数据类型的大小和对齐`

| 类型 | 大小(以字节计) |  对齐方式(以字节计) |
| --- | --- | --- |
| bool | 1 | 1 |
| char <br> int8_t <br> unsigned char <br> uchar <br> uint8_t  | 1 | 1 |
| short <br> int16_t <br> unsigned short <br> ushort <br> uint16_t | 2 | 2 | 
| int <br> int32_t <br> unsigned int <br> uint <br> uint32_t | 4 | 4 |
| half | 2 | 2 |
| float | 4 | 4 |


## 2.2 矢量和矩阵

Metal支持由系统向量数学课实现的向量数据类型的子集。

支持的向量类型名称是：
`booln`、`charn`、`shortn`、`intn`、`ucharn`、`ushort`、`uintn`、`halfn`和`floatn`。
其中`n`是2、3或4，表示2-、3-、4-组向量类型。表3列出了向量数据类型的大小和对齐方式。

`表3 - 向量数据类型的大小和对齐`

| 类型 | 大小(以字节计) |  对齐方式(以字节计) |
| --- | --- | --- |
| bool2 | 2 | 2 |
| bool3 | 4 | 4 |
| bool4 | 4 | 4 |
| char2 <br> uchar2 | 2 | 2 | 
| char3 <br> uchar3 | 4 | 4 | 
| char4 <br> uchar4 | 4 | 4 | 
| short2 <br> ushort2 | 4 | 4 |
| short3 <br> ushort3 | 8 | 8 |
| short4 <br> ushort4 | 8 | 8 |
| int2 <br> uint2 | 8 | 8 |
| int3 <br> uint3 | 16 | 16 |
| int4 <br> uint4 | 16 | 16 |
| half2 | 4 | 4 |
| half3 | 8 | 8 |
| half4 | 8 | 8 |
| float2 | 8 | 8 |
| float3 | 16 | 16 |
| float4 | 16 | 16 |

### 2.2.1 访问向量组件

可以使用数组索引访问向量组件。数组索引0表示向量的第一个组件，索引1表示第二个组件，以此类推。以下示例显示了访问阵列组件的各种方法：

```metal
pos = float4(1.0f, 2.0f, 3.0f, 4.0f);

float x = pos[0]; // x = 1.0
float x = pos[2]; // z = 3.0

float4 vA = float4(1.0f, 2.0f, 3.0f, 4.0f);
float3 vB;

for (int i=0; i<4; i++)
    vB[i] = vA[i] * 2.0f // vB = (2.0, 4.0, 6.0, 8.0); 
```

Metal 支持使用点(.)作为选择运算符来访问向量组件，使用可以指示坐标或者颜色数据的字母：

```metal
<vector_data_type>.xyzw
<vector_data_type>.rgba
```

在以下的代码中，初始化向量test，然后使用.xyzw或.rgba选择语法访问组件：

```metal
int4 test = int4(0, 1, 2, 3);
int a = test.x; // a = 0
int b = test.y; // b = 1
int c = test.z; // c = 2
int d = test.w; // d = 3
int e = test.r; // e = 0
int f = test.g; // f = 1
int g = test.b; // g = 2 
int h = test.a; // h = 3 
```

组件选择语法允许选择多个组件。

```metal
float4 c;
c.xyzw = float4(1.0f, 2.0f, 3.0f, 4.0f);
c.z = 1.0f;
c.xy = float2(3.0f, 4.0f);
c.xyz = float3(3.0f, 4.0f, 5.0f);
```

组件选择语法还允许组件被置换或复制。

```metal
float4 pos = float4(1.0f, 2.0f, 3.0f, 4.0f);
float4 swiz = pos.wzyx; // swiz = (4.0f, 3.0f, 2.0f, 1.0f)
float4 dup = pos.xxyy;  // dup = (1.0f, 1.0f, 2.0f, 2.0f)
```

组件组表示可以出现在表达式的左侧。为了形成左值，可以应用混合。得到的左值可以是标量或向量类型，具体取决于指定的组件数量。生成的向量类型的左值不得包含重复的组件。

```metal
float4 pos = float4(1.0f, 2.0f, 3.0f, 4.0f);
// pos = (5.0, 2.0, 3.0, 6.0)
pos.xw = float2(5.0f, 6.0f);
// pos = (8.0, 2.0, 3.0, 7.0)
pos.wx = float2(7.0f, 8.0f);
// pos = (3.0, 5.0, 9.0, 7.0)
pos.xyz = float3(3.0f, 5.0f, 9.0f);
```

不允许使用以下的向量组件访问方法，会导致编译时错误：

* 访问超出向量类型声明的组件是错误的。2-组件向量数据类型只能访问.xy或.rg元素。3-组件向量数据类型只能访问 .xyz或.rgb元素。

    ```metal
    float2 pos;
    pos.x = 1.0f; // is legal; so is y
    pos.z = 1.0f; // is illegal; so is w
    float3 pos;
    pos.z = 1.0f; // is legal
    pos.w = 1.0f; // is illegal
    ```

* 在左侧访问相同的组件两次是不明确的，是一个错误。

    ```metal
     // illegal - 'x' used twice
     pos.xx = float2(3.0f, 4.0f);
    ```

* 访问不同数量的组件是错误的。

    ```metal
    // illegal - mismatch between float2 and float4
    pos.xy = float4(1.0f, 2.0f, 3.0f, 4.0f);
    ```

* 在单次访问中混合.rgba和.xyzw语法是错误的。

    ```metal
    float4 pos = float4(1.0f, 2.0f, 3.0f, 4.0f);
    pos.x = 1.0f; // OK
    pos.g = 2.0f; // OK
    pos.xg = float2(3.0f, 4.0f); // illegal - mixed attributes used
    float3 coord = pos.ryz;  // illegal - mixed attributes used
    ```

* 带有 swizzles的向量的指针或引用是错误的。

    ```metal
    float4 pos = float4(1.0f, 2.0f, 3.0f, 4.0f);
    my_func(&pos.xy); // illegal
    ```

向量类型的`sizeof`运算符返回向量的大小，该大小以组件数*每个组件的大小给出。例如，`sizeof(float4)`返回16，`sizeof(half4)`返回8。

### 2.2.2 矢量构造函数

构造函数可用于从一组标量或向量创建向量。初始化向量时，其参数签名确定其构造方式。例如，如果仅使用单个标量初始化向量，则构造向量的所有组件都将设置为该标量值。

如果向量是由多个标量，一个或多个向量或这些向量的混合构成的，则从参数的组成部分开始按顺序构造向量的组件。参数从左到右消耗。在消耗下一个参数的任何组件之前，每个参数都按顺序使用其所有组件。

这是一个可用于`float4`的构造函数的完整列表：

```metal
float4(float x);
float4(float x, float y, float z, float w);
float4(float2 a, float2, b);
float4(float a, float b, float2 c);
float4(float a, float2 b, float c);
float4(float3 a, float b);
float4(float a, float3 b);
float4(float4 x);
```

这是一个可用于`float3`的构造函数的完整列表：

```metal
float3(float x); 
float3(float x, float y, float z);  
float3(float a, float2 b);  
float3(float2 a, float b);  
float3(float3 x);
```

这是一个可用于`float2`的构造函数的完整列表：

```metal
float2(float x); 
float2(float x, float y);  
float2(float2 x);
```

以下示例说明了构造函数的用法：

```metal
float x = 1.0f, y = 2.0f, z = 3.0f, w = 4.0f; 
float4 a = float4(0.0f); 
float4 b = float4(x, y, z, w); 
float2 c = float2(5.0f, 6.0f);

float2 a = float2(x, y);
float2 b = float2(z, w);
float4 x = float4(a.xy, b.xy);
```

初始化向量构造函数是一个编译时错误。


### 2.2.3 打包向量类型

2.2节中描述的向量数据类型和向量大小对齐方式。开发人员还可以要求他们的向量数据紧密包装。例如，顶点结构可以包含紧密包装的位置、法线、切线向量和纹理坐标，并作为缓冲区传递给顶点函数。

支持的打包向量类型名称是：
`packed_charn`、`packed_shortn`、`packed_intn`、`packed_ucharn`、`packed_ushortn`、`packed_uintn`、`packed_halfn`和`packed_floatn`。
其中`n`是2、3或4，分别代表2-、3-或4-组分向量类型。（`packed_booln`向量类型名称是保留的。）

表4列出了打包向量数据类型的大小和对齐方式。

| 类型 | 大小(以字节计) |  对齐方式(以字节计) |
| --- | --- | --- |
| packed_char2, <br> packed_uchar2 | 2 | 1 |
| packed_char3, <br> packed_uchar3 | 3 | 1 |
| packed_char4, <br> packed_uchar4 | 4 | 1 |
| packed_short2, <br> packed_ushort2 | 4 | 2 |
| packed_short3, <br> packed_ushort3 | 6 | 2 |
| packed_short4, <br> packed_ushort4 | 8 | 2 |
| packed_int2, <br> packed_uint2 | 8 | 4 |
| packed_int3, <br> packed_uint3 | 12 | 4 |
| packed_int4, <br> packed_uint4 | 16 | 4 |
| packed_half2 | 4 | 2 |
| packed_half3 | 6 | 2 |
| packed_half4 | 8 | 2 |
| packed_float2 | 8 | 4 |
| packed_float3 | 12 | 4 |
| packed_float4 | 16 | 4 |

打包的向量数据类型通常用作数据存储格式。从打包的向量数据类型加载和存储到对齐的向量数据类型，反之亦然。支持复制构造函数和赋值运算符。打包向量数据类型也支持算术、逻辑和关系运算符。

例如：

```metal
device float4 *buffer;
device packed_float4 *packed_buffer;
int i;
packed_float4 f ( buffer[i] );
pack_buffer[i] = buffer[i];
// operator to convert from packed_float4 to float4
buffer[i] = float4( packed_buffer[i] );
```

可以使用数组索引访问打包向量数据类型的组件。但是无法使用`.xyzw`或`.rgba`选择语法访问打包向量数据类型的组件。

例如：

```metal
packed_float4 f;
f[0] = 1.0f;  // OK
f.x = 1.0f;   // Illegal - compilation error
```

# 2.3 矩阵数据类型

Metal支持由系统数学库实现的矩阵数据类型的子集。支持的矩阵类型名称是：
`halfnxm` 和 `floatnxm`
其中n和m是列数和行数。n和m必须是2、3或4。`floatnxm`类型的矩阵由n个`floatm`向量组成。类似的，`halfnxm`类型的矩阵由n个半向量组成。

表5列出了矩阵数据类型的大小和对齐方式。

| 类型 | 大小(以字节计) |  对齐方式(以字节计) |
| --- | --- | --- |
| half2x2 | 8 | 4 |
| half2x3 | 16 | 8 |
| half2x4 | 16 | 8 |
| half3x2 | 12 | 4 |
| half3x3 | 24 | 8 |
| half3x4 | 24 | 8 |
| half4x2 | 16 | 4 |
| half4x3 | 32 | 8 |
| half4x4 | 32 | 8 |
| float2x2 | 16 | 8 |
| float2x3 | 32 | 16 |
| float2x4 | 32 | 16 |
| float3x2 | 24 | 8 |
| float3x3 | 48 | 16 |
| float3x4 | 48 | 16 |
| float4x2 | 32 | 8 |
| float4x3 | 64 | 16 |
| float4x4 | 64 | 16 |

### 2.3.1 访问矩阵组件

可以使用数组下标语法访问矩阵的组件。将单个下表应用于矩阵将矩阵视为列向量的数组。两个下标选择一列，然后选择一行。顶部列是第0列，然后第2个下标对结果向量进行操作，如前面对向量所定义的那样。

```metal
float4x4 m;
// sets the 2nd column to all 2.0
m[1] = float4(2.0f);
// sets the 1st element of the 1st column to 1.0
m[0][0] = 1.0f;
// sets the 4th element of the 3rd column to 3.0
m[2][3] = 3.0f;
```

`floatnxm`和`halfnxm`矩阵可以作为n个`floatm`或n个`halfm`条目的数组进行访问。

使用非常量表达式访问矩阵边界之外的组件会导致未定义的行为。使用常量表达式访问矩阵边界之外的矩阵组件会导致编译时错误。

### 2.3.2 矩阵构造函数

构造函数可用于从一组标量、向量或者矩阵创建矩阵。初始化矩阵时，其参数签名决定了它的构造函数。例如，如果仅使用单个标量初始化矩阵，则结果是包含矩阵对角线的所有分量的标量的矩阵，其余分量初始化为0.0。例如调用
 `float4x4(fval);`
其中`fval`是标量浮点值，用这些初始内容构造一个矩阵：

```metal 
fval 0.0 0.0 0.0
0.0 fval 0.0 0.0
0.0 0.0 fval 0.0
0.0 0.0 0.0 fval
```

矩阵也可以由具有相同大小的另一个矩阵构成；即，具有相同数量的行和列。例如，

```metal
float3x4(float3x4);
float3x4(half3x4);
```

矩阵组件按列主要顺序构建和使用。矩阵构造函数必须在其参数中指定足够的值，以初始化构造的矩阵对象中的每个组件。提供多余必要的参数会导致错误。初始化矩阵构造函数会导致编译时错误。

具有n列和m行的类型T的矩阵也可以由具有m个分量的类型T的n个向量构成。以下示例是合法的构造函数：

```metal
float2x2(float2, float2);
float3x3(float3, float3, float3);
float3x2(float2, float2, float2);
```

从Metal v2.0开始，具有n列和m行的类型T的矩阵也可以由类型为T的n*m个标量构成。以下示例是合法的构造函数：

```metal
float2x2(float, float, float, float);
float3x2(float, float, float, float, float, float);
```

以下是不受支持的矩阵构造函数的示例。不能从向量和标量的组合构造矩阵。

```metal
// not supported
float2x3(float2 a, float b, float2 c, float d);
```

# 2.4 数据类型对齐方式

`alignas`对齐说明符可用于指定类型或对象的对齐要求。`alignas`说明符可以应用于变量的声明结构或类的数据成员。它也可以应用于struct、class、或 enumeration 类型的声明。

Metal编译器负责根据数据类型的要求将数据项对齐到适当的对齐方式。对于声明为数据类型指针的图形或内核函数的参数，Metal编译器可以假定指针对象始终根据数据类型的要求进行适当的对齐。

# 2.5 原子数据类型

原子类型的对象是唯一没有数据竞争的Metal着色语言对象。如果一个线程写入原子对象而另一个线程从中读取，则行为是明确定义的。

支持如下这些原子类型：

`atomic_int` 所有的系统，Metal 1.0 以上版本
`atomic_uint` 所有的系统，Metal 1.0 以上版本
`atomic_bool` iOS系统 Metal 2.0 以上版本；macOS 不支持
`atomic<T>`  iOS系统 Metal 2.0 以上版本；macOS 不支持

`atomic<T>` 表示模板化类型，其中T可以是`int`、`uint`或`bool`。

Metal原子数据类型仅限于Metal原子功能使用，如第5.13节所述。这些原子函数是C++ 14原子和同步函数的子集。

## 2.6 像素数据类型（Pixel Data Types）

> 所有操作系统：自v2.0后支持像素数据类型。

Metal像素数据类型是模板化类型，其描述像素格式类型及其对应的ALU类型。ALU类型表示加载操作返回的类型以及为存储操作指定的输入类型。像素数据类型通常在所有地址空间中可用（有关地址空间的详细信息，请参阅第4.2节）。

表6列出了Metal着色语言中支持的像素数据类型，以及它们的大小和对齐方式。

| 像素数据类型 | T的可选类型 | 大小（字节） | 大小（字节） |
| ---  | --- | --- |  --- |
| r8unorm<T> | half 或 float | 1 | 1 |
| r8snorm<T> | half 或 float | 1 | 1 |
| r16unorm<T> | float | 2 | 2 |
| r16snorm<T> | float | 2 | 2 |
| rg8unorm<T> | half2 或 float2 | 2 | 1 |
| rg8snorm<T> | half2 或 float2 | 2 | 1 |
| rg16unorm<T> | float2 | 4 | 2 |
| rg16snorm<T> | float2 | 4 | 2 |
| rgba8unorm<T> | half4 或 float4 | 4 | 1 |
| srgba8unorm<T> | half4 或 float4 | 4 | 1 |
| rgba8snorm<T> | half4 或 float4 | 4 | 1 |
| rgba16unorm<T> | float4 | 8 | 2 |
| rgba16snorm<T> | float4 | 8 | 2 |
| rgb10a2<T> | half4 或 float4 | 4 | 4 |
| rg11b10f<T> | half3 或 float3 | 4 | 4 |
| rgb9e5<T> | half3 或 float3 | 4 | 4 |

仅允许像素数据类型与其对应的ALU类型之间的分配和等式/不等式比较。（下面的代码中出现的 `buffer(n)`属性将在4.3.1节中解释）

例子：

```metal
kernel void
my_kernel(device rgba8unorm<half4> *p [[buffer(0)]],
          uint gid [[thread_position_in_grid]], …)
{
    rgba8unorm<half4> x = p[index]; half4 val = p[gid];
    …
    p[gid] = val;
    p[index] = x; 
}
```

例子：

```metal
struct Foo {
    rgba8unorm<half4> a;
}; 

kernel void 
my_kernel(device Foo *p [[buffer(0)]], 
        uint gid [[thread_position_in_grid]], …) 
{
    half4 a = p[gid].a;
    …
    p[gid].a = a; 
}

```

# 2.7 缓冲区(Buffers)



# 2.8 纹理(Texture)

纹理数据类型用来处理一维、二维、三维纹理数据， 对应着一个或者所有的纹理的贴图层级 如下的模板定义了指定的纹理数据类型：

```metal
enum class access { sample, read, write, read_write };
texture1d<T, access a = access::sample> 
texture1d_array<T, access a = access::sample> 
texture2d<T, access a = access::sample> 
texture2d_array<T, access a = access::sample> 
texture3d<T, access a = access::sample> 
texturecube<T, access a = access::sample> 
texturecube_array<T, access a = access::sample> 
texture2d_ms<T, access a = access::read> 
```

带深度格式的纹理必须申明为如下的纹理数据类型：

```metal
depth2d<T, access a = access::sample>
depth2d_array<T, access a = access::sample>
depthcube<T, access a = access::sample>
depthcube_array<T, access a = access::sample>
depth2d_ms<T, access a = access::read> 
```

`T`指定了从纹理中读取的 或者写入到纹理中的单组颜色类型， 对于除了深度纹理类型的其他纹理类型，T可以是`half`、`float`、`short`、`ushort`、`int` 或者 `uint`。 深度纹理类型，`T`必须是`float`。

注意：如果`T`是 `int`或者`short`，与纹理关联的数据必须使用带符号的整型格式。如果`T`是`uint`或者是`ushort`，与纹理关联的数据必须使用无符号的整型格式。如果`T`是`half`，与纹理关联的数据必须使用归一化(normalized)的（带符号或者无符号的整型）或者半精度的格式。如果`T`是`float`，与纹理关联的数据必须使用归一化(normalized)的（带符号或者无符号的整型）或者单精度的格式。

`access`属性描述了纹理的访问权限，如下列举了支持的属性。

* `sample` - 纹理对象可以被采样。`sample`意味着可以不使用采样器直接读取纹理的能力。
* `read` - 显卡或者内核函数只能从纹理读取数据。
* `write` - 显卡或者内核函数可以写入数据到纹理对象中。
* `read_write` - 显卡或者内核函数可以读写纹理对象。

所有的系统: `read_write` 访问权限从Metal 1.2 开始支持。而其他的访问权限从Metal 1.0就开始支持。

注意：对于多重采样纹理，只能使用`read`修饰符。对于深度纹理，只能使用 `sample`和`read`修饰符。

如下的例子

```metal
void foo (texture2d<float> imgA [[texture(0)]],
 texture2d<float, access::read> imgB [[texture(1)]],
texture2d<float, access::write> imgC [[texture(2)]])
{…} 
```
(See section 4.3.1 for a description of the texture attribute.) 

纹理类型可以用来作为函数内任何申明的变量类型。定义在函数内部的纹理类型的权限修饰符只能使用`acess::read`或者 `access::sample`。在函数方法体中如果不用`acess::read`或`access::sample`修饰符来定义纹理类型会报编译错误。

例子：

```metal
void foo (texture2d<float> imgA [[ texture(0) ]], 
          texture2d<float, access::read> imgB [[ texture(1) ]],
          texture2d<float, access::write> imgC [[ texture(2) ]])
{
    texture2d<float> x = imgA; // legal
    texture2d<float, access::read> y = imgB; // legal
    texture2d<float, access::write> z; // illegal 
    ...
}
```

### 2.8.1 纹理Buffers

所有的系统：纹理Buffers 在Metal2.1开始支持。




## 2.9 采样器（Samplers）

`sampler`类型指定了如何对纹理进行采样。Metal API 允许你创建一个sampler对象并将其作为参数传给图像或者内核函数。

| 枚举名称 | 可取值 | 描述 |
| ---  | --- | --- |
| coord | normalized(默认值) <br> pixel | 1 |
| address | repeat <br> mirrored_repeat <br> clamp_to_edge(默认值) <br> clamp_to_zero <br> clamp_to_border | xxx |
| s_address <br> t_address <br> r_address | repeat <br> mirrored_repeat <br> clamp_to_edge(默认值) <br> clamp_to_zero <br> clamp_to_border | 2 |
| border_color | transparent_black (默认值) <br> opaque_black <br> opaque_white | 4 |
| filter | nearest(默认值) <br> linear | 2 |
| mag_filter | nearest（默认值） <br> linear  | 设置纹理采样时的放大滤波模式 |
| min_filter | nearest（默认值） <br> linear | 设置纹理采样时的缩小滤波模式 |
| mip_filter | none(默认值) <br> nearest <br> linear | 设置纹理采样时的mipmap过滤模式。如果为`none`,那么 |
| compare_func | never（默认值）<br> less <br> less_equal <br> greater <br> greater_equal <br> equal <br> not_equal <br> always | xx |

```metal
constexpr sampler s(coord::pixel, address::clamp_to_zero, filter::linear);

constexpr sampler a(coord::normalized);

constexpr sampler b(address::repeat);

constexpr sampler s(address::clamp_to_zero, filter::linear, compare_func::less);

constexpr sampler s(address::clamp_to_zero, filter::linear, compare_func::less, max_anisotropy(10), lod_clamp(0.0f, MAXFLOAT));
kernel void
my_kernel(device float4 *p [[buffer(0)]],
        texture2d<float> img [[texture(0)]],
        sampler smp [[sampler(3)]],
        …)
{
        …
} 
```

## 2.10 Imageblocks



## 2.9 Size 和

| 类型 | Size（字节） | Alignment（字节） |
| ---  | --- | --- |
| bool | 1 | 1 |
| char, <br> uchar | 1 | 1 |
| short, <br> ushort | 2 | 2 |
| int, <br> uint | 4 | 4 |
| half | 2 | 2 |

## 2.10 Imageblocks

iOS: imageblock Metal 2.0 以上支持
macOS： 不支持 imageblocks

一个图片块是一个二维的数据结构（用宽、高、以及一组采样器）

## 2.15 隐式类型转换

例如：

```metal
float4 f = 2.0; // f = (2.0f, 2.0f, 2.0f, 2.0f)
```