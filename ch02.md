# 2 数据类型

## 2.1 标量数据类型
Metal 支持`表1`中罗列的标量类型，Metal 不支持 `double`, `long`, `unsigned long`, `long long`, `unsigned longlong`以及 `long double` 数据类型。

`表1 - Metal 标量数据类型`

| 类型 | 描述 |
| --- | --- |
| bool | 条件数据类型，用来判断值是true或者false。 值 true 扩展了整数常量1，值 false 扩展了整数常量0. |
| char <br> int8_t | 带符号的二进制 |
| unsigned char <br> uchar <br> uint8_t  |  一个无符号的8位整数 |
| short <br> int16_6|  |
| int <br> int32_t | 32位整型 |
| unsigned int <br> uint <br> uint32_t |  |
| half | |
| float | |
| size_t| | 
| ptrdiff_t | |
| void | void  |

NOTE:

## 2.2 矢量和矩阵

```
    bool
    charn, shortn, intn, ucharn
```

### 2.2 矢量构造函数

如下是`float4`所有可用的构造函数：

```
    float4(float x);
    float4(float x, float y, float z, float w);
    float4(float2 a, float2, b);
    float4(float a, float b, float2 c);
    float4(float a, float2 b, float c);
    float4(float3 a, float b);
    float4(float a, float3 b);
    float4(float4 x);
```

如下是`float3`所有可用的构造函数：

```
    float3(float x); 
    float3(float x, float y, float z);  
    float3(float a, float2 b);  
    float3(float2 a, float b);  
    float3(float3 x);
```

如下是`float2`所有可用的构造函数：

```
    float2(float x); 
    float2(float x, float y);  
    float2(float2 x);
```

下面的列子演示了怎样使用这些构造函数：

```
    float x = 1.0f, y = 2.0f, z = 3.0f, w = 4.0f; 
    float4 a = float4(0.0f); 
    float4 b = float4(x, y, z, w); 
    float2 c = float2(5.0f, 6.0f);

    float2 a = float2(x, y);
    float2 b = float2(z, w);
    float4 x = float4(a.xy, b.xy);
```


### 2.2.4 矩阵构造函数




## 2.5 原子数据类型

`atomic_int` 所有的系统，Metal 1.0 以上版本
`atomic_uint` 所有的系统，Metal 1.0 以上版本
`atomic_bool` iOS系统 Metal 2.0 以上版本；macOS 不支持
`atomic<T>`  iOS系统 Metal 2.0 以上版本；macOS 不支持

atomic<T> represents templated types, where T can be int, uint, or bool.
The Metal atomic data type is restricted for use by Metal atomic functions, as described in
section 5.13. These atomic functions are a subset of the C++14 atomic and synchronization
functions. 

## 2.6 像素数据类型（Pixel Data Types）

| 像素数据类型 | T的可选类型 | 大小（字节） | 大小（字节） |
| ---  | --- | --- |  --- |
| r8unorm<T> | half 或者 float | 1 | 1 |
| r8snorm<T> | half 或者 float | 1 | 1 |
| r16unorm<T> | float | 2 | 2 |
| r16snorm<T> | float | 2 | 2 |
| rg8unorm<T> | half2 或者 float2 | 2 | 1 |
| rg8snorm<T> | half2 或者 float2 | 2 | 1 |
| rg16unorm<T> | float2 | 4 | 2 |
| rg16snorm<T> | float2 | 4 | 2 |
| rgba8unorm<T> | half4 或者 float4 | 4 | 1 |
| srgba8unorm<T> | half4 或者 float4 | 4 | 1 |
| rgba8snorm<T> | half4 或者 float4 | 4 | 1 |
| rgba16unorm<T> | float4 | 8 | 2 |
| rgba16snorm<T> | float4 | 8 | 2 |
| rgb10a2<T> | half4 或者 float4 | 4 | 4 |
| rg11b10f<T> | half3 或者 float3 | 4 | 4 |
| rgb9e5<T> | half3 或者 float3 | 4 | 4 |


例子：

```metal
kernel void
my_kernel(device rgba8unorm<half4> *p [[buffer(0)]],
          uint gid [[thread_position_in_grid]], …)
{
    rgba8unorm<half4> x = p[index]; half4 val = p[gid];
    …
    p[gid] = val;
    p[index] = x; 
}
```

例子：

```metal
struct Foo {
    rgba8unorm<half4> a;
}; 

kernel void 
my_kernel(device Foo *p [[buffer(0)]], 
        uint gid [[thread_position_in_grid]], …) 
{
    half4 a = p[gid].a;
    …
    p[gid].a = a; 
}

```

## 2.7 Buffers

## 2.8 纹理(Texture)

纹理数据类型用来处理一维、二维、三维纹理数据， 对应着一个或者所有的纹理的贴图层级 如下的模板定义了指定的纹理数据类型：

```metal
enum class access { sample, read, write, read_write };
texture1d<T, access a = access::sample> 
texture1d_array<T, access a = access::sample> 
texture2d<T, access a = access::sample> 
texture2d_array<T, access a = access::sample> 
texture3d<T, access a = access::sample> 
texturecube<T, access a = access::sample> 
texturecube_array<T, access a = access::sample> 
texture2d_ms<T, access a = access::read> 
```

带深度格式的纹理必须申明为如下的纹理数据类型：

```metal
depth2d<T, access a = access::sample>
depth2d_array<T, access a = access::sample>
depthcube<T, access a = access::sample>
depthcube_array<T, access a = access::sample>
depth2d_ms<T, access a = access::read> 
```

`T`指定了从纹理中读取的 或者写入到纹理中的单组颜色类型， 对于除了深度纹理类型的其他纹理类型，T可以是`half`、`float`、`short`、`ushort`、`int` 或者 `uint`。 深度纹理类型，`T`必须是`float`。

注意：如果`T`是 `int`或者`short`，与纹理关联的数据必须使用带符号的整型格式。如果`T`是`uint`或者是`ushort`，与纹理关联的数据必须使用无符号的整型格式。如果`T`是`half`，与纹理关联的数据必须使用归一化(normalized)的（带符号或者无符号的整型）或者半精度的格式。如果`T`是`float`，与纹理关联的数据必须使用归一化(normalized)的（带符号或者无符号的整型）或者单精度的格式。

`access`属性描述了纹理的访问权限，如下列举了支持的属性。

* `sample` - 纹理对象可以被采样。`sample`意味着可以不使用采样器直接读取纹理的能力。
* `read` - 显卡或者内核函数只能从纹理读取数据。
* `write` - 显卡或者内核函数可以写入数据到纹理对象中。
* `read_write` - 显卡或者内核函数可以读写纹理对象。

所有的系统: `read_write` 访问权限从Metal 1.2 开始支持。而其他的访问权限从Metal 1.0就开始支持。

注意：对于多重采样纹理，只能使用`read`修饰符。对于深度纹理，只能使用 `sample`和`read`修饰符。

如下的例子

```metal
void foo (texture2d<float> imgA [[texture(0)]],
 texture2d<float, access::read> imgB [[texture(1)]],
texture2d<float, access::write> imgC [[texture(2)]])
{…} 
```
(See section 4.3.1 for a description of the texture attribute.) 

### 2.8.1 纹理Buffers



## 2.9 采样器（Samplers）

`sampler`类型指定了如何对纹理进行采样。

## 2.7 数组和结构体



## 2.9 Size 和

| 类型 | Size（字节） | Alignment（字节） |
| ---  | --- | --- |
| bool | 1 | 1 |
| char, <br> uchar | 1 | 1 |
| short, <br> ushort | 2 | 2 |
| int, <br> uint | 4 | 4 |
| half | 2 | 2 |

## 2.10 Imageblocks

iOS: imageblock Metal 2.0 以上支持
macOS： 不支持 imageblocks

一个图片块是一个二维的数据结构（用宽、高、以及一组采样器）